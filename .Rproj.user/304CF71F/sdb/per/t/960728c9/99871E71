{
    "collab_server" : "",
    "contents" : "---\ntitle: \"sidtoolbox\"\noutput: html_document\nauthor: Marzie Rasekh\n---\n# Subgroup discovery demonstration\n\n```{r load_packaged, message=FALSE, warning=FALSE, include=FALSE}\n\n# or by indices\nlibrary(devtools)\nlibrary(roxygen2)\n\n#install(\".\")\n# or load it\nlibrary(sidtoolbox)\n# update if changes made\ndocument()\nlibrary(data.table)\nlibrary(stringr)\nlibrary(ggplot2)\n\n```\n\n\n# Load data from siddata file\n```{r loadData}\ndata <- fread(input = \"jiwen/siddata.txt\", stringsAsFactors = TRUE)\ndata <- data[, c(\"V1\", \"USUBJID\", \"AGEGR1\", \"COUNTRY\", \"SEX\", \"REGION1\", \"INISTG\", \"BOR\") := NULL]\nhead(data)\nlevels(data$CUSTG) <- c(1, 2, 3, 4)\nlevels(data$BONEONLY) <- c(0, 1)\nlevels(data$LULIINV) <- c(0, 1)\nlevels(data$LIVERINV) <- c(0, 1)\nlevels(data$LULIINV) <- c(0, 1)\nlevels(data$ECOGBL) <- c(0, 1, 2, NA)\nlevels(data$OTHMTSI) <- c(0, 1)\nlevels(data$NMTSI) <- c(0, 1, 2, 3)\n\n## BOR: est overall response with confirmation PR=Partial response, CR=complete response, SD=stable disease, NCRNPD=non CR non PD, UNK=unknown\n## TTP: time to progression (days)\noutcomes <- c(\"CRPRresponse\", \"TTP\")\noutcomeTypes <- c(\"binary\", \"survival\")\ncovariates <- setdiff(colnames(data), c(outcomes))\n\nsubgroup.data <- loadDataset(dataset = data, \n                             covariates = covariates, \n                             outcomes = outcomes, \n                             outcomeTypes = outcomeTypes)\n\nfwrite(x = subgroup.data$data, file = \"jiwen.txt\")\ndim(subgroup.data$data)\n\n```\n\n\n## Explore the data\nThis step helps identify covariates to be included in the subgroup discovery.\n\n### Correlation matrix\nCorrelations who one on one relation in your data. Highly correlated covariates should be removed.\n\n```{r exploreCorrelationMatrix}\n\n# examples\nexploreTriangleCorrelationMatrix(subgroup.data = subgroup.data, method = \"spearman\")\nexploreCorrelationMatrix(subgroup.data = subgroup.data)\nexploreDetailedChartCorrelation(subgroup.data = subgroup.data)\n\n\n```\n\n### Association rules\nAssociation rules help us find high level correlations in our data. \nThe rules are controled by support (how large the corresponding subgroup is) and confidence (how many of the total subgroup size follow the rule).\n\n```{r exploreAssociationRules, message=FALSE, warning=FALSE}\n\n# res <- exploreAssociationRules(subgroup.data)\n\nplotAssociationRules(subgroup.data = subgroup.data, onlyCovariates = TRUE)\nplotAssociationRules(subgroup.data = subgroup.data, method = \"graph\", measure = \"confidence\", onlyCovariates = TRUE)\nplotAssociationRules(subgroup.data = subgroup.data, method = \"scatterplot\", measure = \"support\", onlyCovariates = TRUE)\nplotAssociationRules(subgroup.data = subgroup.data, method = \"two-key plot\", measure = \"support\", onlyCovariates = FALSE)\n#plotAssociationRulesInteractive(subgroup.data = subgroup.data, onlyCovariates = TRUE)\nrules <- listAssociationRules(subgroup.data = subgroup.data, onlyCovariates = TRUE, support = 0.2, confidence = 0.5)\nrules\n\n\n\n```\n\n### Conditional inference tree\nConditional inference trees are useful to fund the false positive subgroups, where both arms are shifted.\n\n\n```{r exploreDecisionTree, message=FALSE, warning=FALSE}\n# the true positive / false positive subgroup is\n# subgroup.data$rules\nlapply(X = subgroup.data$outcomes, FUN = function(y) {\n  plot(\n    exploreConditionalInferenceTree(subgroup.data = subgroup.data, y_idx = y, stump = FALSE, testtype = \"Bonferroni\", significance = 0.05, nmin = 0.1, maxdepth = 4)\n  )\n})\n\n```\n\n\n\n### Clustering \n\n\n```{r clustering}\n# coming soon\n\n```\n\n## Subgroup discovery\n\n```{r subgroup_discovery}\n# set the outcomes you want to run subgroup discovery on\noutcome_columns <- colnames(subgroup.data$data)[subgroup.data$outcomes]\n# save all rules in allRules\nallRules <- subgroup.data$rules\nallRules\n\n```\n\n### Treatment-specific Subgroup Discovery Tool (TSDT)\n<b>\nBattioui, C., Shen, L., Ruberg, S., (2014). <i>A Resampling-based Ensemble Tree Method to Identify\nPatient Subgroups with Enhanced Treatment Effect.</i> JSM proceedings, 2014 </b>\n\n```{r TSDT, message=FALSE, warning=FALSE}\n# the true positive / false positive subgroup is\n# subgroup.data$rules\n\nparam <- list(\n  desirable_response = \"increasing\",\n  nsamples = 100, \n  npermutations = 100, \n  maxdepth = 4, \n  min_subgroup_n_control = 0.1, \n  min_subgroup_n_trt = 0.1, \n  n_cpu = 1\n)\n\nresTSDT <- lapply(X = outcome_columns, FUN = function(y_idx) {\n  res <- runTSDT(subgroup.data = subgroup.data, \n                     y_idx = y_idx,\n                     desirable_response = param$desirable_response,\n                     nsamples = param$nsamples, \n                     npermutations = param$npermutations, \n                     maxdepth = param$maxdepth,\n                     n_cpu = param$n_cpu)\n  allRules <<- rbind(allRules, \n                    parseTSDTResults(TSDT_table = res, outcome = y_idx, param = param, filter = \"Strong\"))\n  return(res)\n})\n\nresTSDT\n\n```\n\n\n### Optimization approach with Particle Swarm Optimization (PSO)\n\n```{r PSO}\n# the true positive / false positive subgroup is\n# subgroup.data$rules\n\nresPSO <- lapply(X = outcome_columns,\n                 FUN = function(y_idx){\n  pso <- runPSO(subgroup.data = subgroup.data, \n                y_idx = y_idx, \n                fitness_method = NULL, \n                desirable_response = \"increasing\", \n                depth = 2, \n                nmin = 0.1, \n                iterations = 1000)\n  allRules <<- rbind(allRules, \n                     pso)\n  pso\n})\nresPSO\n\n\n\n```\n\n\n## Analyze and compare rules\n\n```{r compare_rules}\nP_THRESHOLD <- -log10(0.05)\nsummarizeRules <- function(subgroup.data, rules) {\n  N.rules <- nrow(rules)\n  summaryRules <- data.table()\n  \n  allOutcomes <- outcome_columns\n  \n  for (i in c(1:N.rules)) {\n    row <- rules[i]\n    # adding a fix to remove dummy rules wihch were negative controls\n    if (!grepl(x = row$rule, pattern = \"dummy\")) {\n      if (str_length(row$outcome) == 0) {\n        Y <- allOutcomes\n      } else {\n        Y <- row$outcome\n      }\n      for (y in Y) {\n        row$outcome <- y\n        summaryRules <- rbind(summaryRules, row)\n      }\n    }\n    \n  }\n  N.rules <- nrow(summaryRules)\n  N <- nrow(subgroup.data$data)\n  effect_size <- sapply(\n    X = c(1:N.rules),\n    FUN = function(i) {\n      row <- summaryRules[i]\n      sbg_idx <-\n        parseRule(covariates = subgroup.data, rule = row$rule)\n      f <- absoluteValue(\n        subgroup.data = subgroup.data,\n        y_idx = row$outcome,\n        subgroup_idx = sbg_idx\n      )\n      c(\n        N_ratio = sum(sbg_idx) / N,\n        effect = f[1],\n        pvalue = f[2]\n      )\n    }\n  )\n  summaryRules$N_ratio <- effect_size[1, ]\n  summaryRules$interaction_coeff <- effect_size[2, ]\n  # check TP rule and get accuracy precision recall\n  truth_subgroup <- which(rules$method == \"sim_TP\")\n  if (length(truth_subgroup) > 0) {\n    truth_subgroup <- parseRule(covariates = subgroup.data,\n                                rule = rules[truth_subgroup[1], ]$rule)\n    performance <- sapply(\n      X = c(1:N.rules),\n      FUN = function(i) {\n        row <- summaryRules[i, ]\n        sbg_idx <-\n          parseRule(covariates = subgroup.data, rule = row$rule)\n        TP <- sum(sbg_idx &  truth_subgroup)\n        FP <- sum(sbg_idx & !truth_subgroup)\n        TN <- sum(!sbg_idx & !truth_subgroup)\n        FN <- sum(!sbg_idx &  truth_subgroup)\n        precision <- TP / (TP + FP)\n        recall <- TP / (TP + FN)\n        F1  <- 2 * (recall * precision) / (precision + recall)\n        c(precision = precision,\n          recall = recall,\n          F1 = F1)\n      }\n    )\n    summaryRules$precision <- performance[1, ] * 100\n    summaryRules$recall <- performance[2, ] * 100\n    summaryRules$F1 <- performance[3, ] * 100\n  }\n  return(summaryRules)\n}\n\ndata <- summarizeRules(subgroup.data = subgroup.data, rules = allRules)\n#data$log_p_value <- -log10(data$p_value)\n  \nggplot(\n  data = data,\n  aes(\n    x = precision,\n    y = recall,\n    shape = outcome,\n    color = method\n  )\n) +\ngeom_point() +\nggtitle(\"Summary of rules\")\n\nggplot(\n  data = data,\n  aes(\n    x = interaction_coeff,\n    y = N_ratio,\n    shape = outcome,\n    color = method,\n     size = 10\n  )\n \n) +\ngeom_point() +\nggtitle(\"Summary of rules\") +\ngeom_text(\n  label = data$method,\n  size = 3\n) + \ngeom_hline(yintercept = P_THRESHOLD)\n\ndata\n\n```\n\n\n\n",
    "created" : 1565370040294.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1744778408",
    "id" : "99871E71",
    "lastKnownWriteTime" : 1565550715,
    "last_content_update" : 1565550818529,
    "path" : "~/sidtoolbox/jiwen.Rmd",
    "project_path" : "jiwen.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}