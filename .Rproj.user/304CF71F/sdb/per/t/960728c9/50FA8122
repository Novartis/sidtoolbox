{
    "collab_server" : "",
    "contents" : "#' load data and set covariates, outcomes, and trt arms for subgroup analysis\n#'\n#' This function takes a dataset in the format of a data.table along with\n#' a list of columns representing covariates and outcomes\n#' and the column containing the factor of treatment arms.\n#' checks that the columns do not overlap, are in bound, and trt is a factor\n#' @param dataset The data containing all patients and covariates, outcomes, and trt (data.table)\n#' @param covariates A vector of the covariate column names or indices (vector)\n#' @param outcomes A vector of the outcome column names or indices (vector)\n#' @param outcomeTypes A vector of the outcome types, in c(\"numeric\", \"binary\", \"count\", \"survival\") (vector)\n#' @param trt the treatment column label or index (integer or character)\n#' @param ctrl the treatment control (a level in trt column)\n#' @param rules a list of rules to be added to subgroup.data (list) default=list()\n#' @return instance of subgroup.data appropriate for subgroup analysis (list)\n#' @export\nloadDataset <- function(dataset, \n                        covariates, \n                        outcomes, \n                        outcomeTypes, \n                        trt = \"\", \n                        ctrl = NULL, \n                        rules = data.table()) {\n  library(data.table)\n  SUPPORTED_OUTCOMES <- c(\"binary\", \"numeric\", \"count\", \"timetoevent\", \"survival\")\n  dataset <- as.data.table(dataset)\n  columns <- colnames(dataset)\n  # check if covariates are colnames or integer indexes\n  if (is.character(covariates)) { # colnames\n    X <- which(columns %in% covariates)\n  }\n  else if (is.numeric(covariates) &&\n           sum(round(covariates) != covariates) == 0) { # indices\n    X <- covariates\n  }\n  else { # error\n    # error\n    stop(\"ERROR: covariates have wrong type, should be colnames or indices.\\n\")\n  }\n  # check if outcomes are colnames or integer indexes\n  if (typeof(outcomes) == \"character\") { # colnames\n    Y <- which(columns %in% outcomes)\n  } else if (is.numeric(outcomes) &&\n             sum(round(outcomes) != outcomes) == 0) {\n    Y <- outcomes\n  } else {\n    # error\n    stop(\"ERROR: outcomes have wrong type, should be colnames or indices.\\n\")\n  }\n  # outcome types should be: binary, numeric, count, time to event / survival\n  # or should I name them: binomial, gaussian, neg binomial, log normal\n  # or lm, glm.binomial, glm.poisson, hazard ratio\n  if (!(is.character(outcomeTypes) && \n      length(outcomeTypes) == length(outcomes) &&\n      sum(sapply(X = outcomeTypes, FUN = function(type) {!type %in% SUPPORTED_OUTCOMES})) == 0)) { # colnames\n    # error\n    stop(paste(\"ERROR: outcomeTypes have wrong type, should be a character in \",\n               'c(\"binary\", \"numeric\", \"count\", \"timetoevent\", \"survival\"), .\\n'))\n  }\n  \n  # check if trt is colname or integer index\n  if (length(trt) == 1 && trt != \"\") {\n    # two arm study\n    if (is.character(trt)) {\n      TRT <- which(columns == trt)\n    } else if (is.numeric(trt) && \n               round(trt) == trt) {\n      TRT <- trt\n    } else {\n      # error\n      stop(paste(\"ERROR: trt has wrong type,\",\n                 typeof(trt),\n                 \"should be colname or index.\\n\"))\n    }\n  } else if(length(trt) == 0 || trt == \"\") {\n    # one arm study\n    TRT <- NULL\n    print(\"Loading one arm study\")\n  } else if (length(trt) > 1) {\n    # error\n    stop(\"ERROR: treatment arm should be atomic (or empty for one arm).\\n\")\n  }\n  # check for outofbound columns\n  outofbound <- setdiff(c(X, Y, TRT), c(1:length(columns)))\n  if(length(outofbound) > 0) {\n    stop(paste(\"ERROR: outofbound error:\", outofbound))\n  }\n  \n  # check if there are overlapping columns\n  if (length(intersect(X, Y)) > 0) {\n    # error\n    stop(\"ERROR: outcomes and covariates overlap\\n\")\n  }\n  # check the treatment arm if two arm study\n  if (!is.null(TRT)) {\n    if (TRT %in% c(X, Y)) {\n      # error\n      stop(\"ERROR: trt overlaps with outcomes/covariates\")\n    }\n    # check if trt is factor\n    trt_data <- dataset[[TRT]]\n    if(!is.factor(trt_data)) {\n      warning(\"WARNING: trt is not a factor, converting now...\\n\")\n      trt_data <- as.factor(trt_data)\n      dataset[[TRT]] <- trt_data\n    }\n    # check if control is in trt and trt has more than 1 level\n    if(!(ctrl %in% levels(trt_data))) {\n      stop(\"ERROR: ctrl=\", ctrl,\" not found in levels of trt.\\n\")\n    }\n    if(length(levels(trt_data)) < 2) {\n      stop(paste(\"ERROR: not enough levels in contrast:\",\n                 length(levels(trt_data)),\n                 \"\\n\"))\n    }\n    \n    # make the structure\n    # make a list of all, refered to as subgroup.data\n    subgroup.data <- list(data = dataset,\n                          covariates = as.vector(X),\n                          outcomes = as.vector(Y),\n                          outcomeTypes = as.vector(outcomeTypes),\n                          contrast = TRT,\n                          control = ctrl,\n                          rules = rules)\n  } else {\n    # make a one arm study structure\n    subgroup.data <- list(data = dataset,\n                          covariates = as.vector(X),\n                          outcomes = as.vector(Y),\n                          outcomeTypes = as.vector(outcomeTypes),\n                          rules = rules)\n  }\n  \n  return(subgroup.data)\n}\n",
    "created" : 1565387658741.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2814482350",
    "id" : "50FA8122",
    "lastKnownWriteTime" : 1565387701,
    "last_content_update" : 1565387701175,
    "path" : "~/sidtoolbox/R/loadDataset.R",
    "project_path" : "R/loadDataset.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}