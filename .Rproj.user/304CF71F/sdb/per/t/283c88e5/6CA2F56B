{
    "collab_server" : "",
    "contents" : "output$featureSelectHelp <- renderUI({\n  if (length(values$sid.data) > 0) {\n    tags$div(\n      tags$p(paste(\"Select the contrast, covariates, and outcomes. \",\n                   \"If this is a one arm study set contrast to empty, otherwise\",\n                   \"select the control arm in the treatment column.\",\n                   \"After selecting outcomes, please specify the type of each.\",\n                   \"After setting all variables, click on\"),\n             tags$i(\"Save feature setting\"),\n             paste(\".\")\n      )\n    )\n  } else {\n    tags$div(\n      tags$p(paste(\"You can start by loading data from file \",\n                   \"or simulating sample data and implanting subgroups.\", \n                   \"Simulation can be used for benchmarking purposes and features will be set automatically.\")\n      )\n    )\n  }\n})\noutput$renderFeatureOutputs <- renderUI({\n  # update feature panel\n  if(length(values$sid.data) == 0) {\n    return()\n  }\n  \n  features <- colnames(values$sid.data$data)\n  \n  if(\"contrast\" %in% names(values$sid.data)) {\n    trt <- features[values$sid.data$contrast]\n    controls <- unique(values$sid.data$data[, trt, with = FALSE])\n    if (\"control\" %in% names(values$sid.data)) {\n      control_selected <- values$sid.data$control\n    } else {\n      control_selected <- NULL\n    }\n  } else {\n    trt <- \"\"\n    controls <- c()\n    control_selected <- NULL\n  }\n\n  if(\"covariates\" %in% names(values$sid.data)) {\n    covariates <- features[values$sid.data$covariates]\n  } else {\n    covariates <- c()\n  }\n  \n  if(\"outcomes\" %in% names(values$sid.data)) {\n    outcomes <- features[values$sid.data$outcomes]\n  } else {\n    outcomes <- c()\n  }\n  \n  tags$div(\n    id = \"featureSelectDiv\",\n    fluidRow(\n      column(\n        width = 6,\n        selectInput(inputId = \"selectContrast\", \n                    label = \"select contrast\",\n                    choices = c(\"\", setdiff(features, c(covariates, outcomes))),\n                    selected = trt)\n      ),\n      column(\n        width = 6,\n        selectInput(inputId = \"selectControl\", \n                    label = \"control\",\n                    choices = controls,\n                    selected = control_selected)\n        )\n    ),\n    fluidRow(\n      column(\n        width = 4,\n        multiInput(inputId = \"selectCovariates\", \n                   label = \"select covariates\",\n                   choices = setdiff(features, c(trt, outcomes)),\n                   selected = covariates)\n      ),\n      column(\n        width = 4,\n        multiInput(inputId = \"selectOutcomes\", \n                   label = \"select outcomes\",\n                   choices = setdiff(features, c(trt, covariates)),\n                   selected = outcomes)\n      ),\n      column(\n        width = 4,\n        uiOutput(outputId = \"selectOutcomesTypes\")\n      )\n    )\n    \n  )\n})\n\noutput$selectOutcomesTypes <- renderUI({\n  req(input$selectOutcomes)\n  outcomes <- input$selectOutcomes\n  req(!is.null(outcomes) && length(outcomes) > 0)\n  req(\"data\" %in% names(values$sid.data))\n  data <- values$sid.data$data\n  req(nrow(data) > 0 && ncol(data) > 0)\n  idx <- 0\n  ui <- lapply(X = outcomes, FUN = function(y){\n    col <- data[, y, with = FALSE][[1]]\n    idx <<- idx + 1\n    if (\"outcomeTypes\" %in% names(values$sid.data) &&\n        length(values$sid.data$outcomeTypes) >= idx) {\n      guess_type <- values$sid.data$outcomeTypes[idx]\n    } else if (is.factor(col) || length(levels(col)) == 2) {\n      guess_type  <- \"binary\"\n    } else if (length(unique(col)) == 2) {\n      guess_type  <- \"binary\"\n    } else if ((is.numeric(col) || is.integer(col)) && round(col) == col) {\n      guess_type  <- \"count\"\n    } else {\n      guess_type <- \"numeric\"\n    }\n    OUTCOME_TYPES <- c(\"numeric\", \"count\", \"survival\", \"binary\")\n    selectInput(inputId = paste(\"type\", y, sep = \"_\"), \n                label = paste(\"Type of\", y), \n                choices = OUTCOME_TYPES, \n                selected = guess_type, \n                multiple = FALSE)\n  })\n  updateFeatureSelect()\n  ui\n})\n\nonevent(\n  event = \"mouseleave\",\n  id = \"selectContrast\",\n  expr = {\n    trt <- input$selectContrast\n    features <- colnames(values$sid.data$data)\n    if (trt %in% features) {\n      ctrl <- unique(as.vector(values$sid.data$data[, trt, with = FALSE][[1]]))\n      updateSelectInput(\n        session, \n        inputId = \"selectControl\", \n        choices = ctrl, selected = ctrl[1])\n    } else {\n      updateSelectInput(\n        session, \n        inputId = \"selectControl\", \n        choices = c(), selected = c())\n    }\n    updateFeatureSelect()\n  }\n)\n\nonevent(\n  event = \"mouseup\",\n  id = \"selectCovariates\",\n  expr = {\n    updateFeatureSelect()\n  }\n)\nonevent(\n  event = \"mouseup\",\n  id = \"selectOutcomes\",\n  expr = {\n    updateFeatureSelect()\n  }\n)\n\nupdateFeatureSelect <- function () {\n  features <- colnames(values$sid.data$data)\n  updateSelectInput(session, \n                    inputId = \"selectContrast\", \n                    choices = c(\"\", setdiff(features, c(input$selectCovariates, input$selectOutcomes))),\n                    selected = input$selectContrast)\n\n  updateMultiInput(session, \n                   inputId = \"selectCovariates\", \n                   choices = setdiff(features, c(input$selectContrast, input$selectOutcomes)),\n                   selected = input$selectCovariates)\n  \n  updateMultiInput(session, \n                   inputId = \"selectOutcomes\", \n                   choices = setdiff(features, c(input$selectContrast, input$selectCovariates)),\n                   selected = input$selectOutcomes)\n}\n    \n\nonclick(\n  id = \"SaveFeatureSelect\", \n  expr = {\n    req(values$sid.data$data)\n    data <- values$sid.data$data\n    \n    if(nrow(data) == 0 || ncol(data) == 0) {\n      shinyjs::alert(text = \"Error: dataset is empty.\")\n      return()\n    }\n    outcomes <- input$selectOutcomes\n    covariates <- input$selectCovariates\n    rules <- values$sid.data$rules\n    trt <- input$selectContrast\n    ctrl <- input$selectControl\n    \n    if (is.null(outcomes) || length(outcomes) == 0) {\n      shinyjs::alert(text = \"Error: outcomes are empty.\")\n      return()\n    }\n    if (is.null(covariates) || length(covariates) == 0) {\n      shinyjs::alert(text = \"Error: covariates are empty.\")\n      return()\n    }\n    \n    outcome_types <- sapply(X = outcomes, FUN = function(y){\n      input[[paste(\"type\", y, sep = \"_\")]]\n    })\n    values$sid.data <-\n      loadDataset(dataset = data, \n                  trt = trt, \n                  ctrl = ctrl,\n                  covariates = covariates,\n                  outcomes = outcomes,\n                  outcomeTypes = outcome_types,\n                  rules = rules)\n})\n\nshinyjs::onclick(\n  id = \"loadData\", \n  expr = {\n    values$sid.data <- list()\n    tryCatch(\n      expr = {\n        print(as.character(input$dataPath$datapath))\n        data <- fread(as.character(input$dataPath$datapath), stringsAsFactors = T)\n        # remove missing data\n        idx <- apply(X = data, MARGIN = 1, FUN = function(row){\n          sum(is.na(row)) == 0\n        })\n        data <- data[idx,]\n        showNotification(paste0(\"data loaded dim=\", dim(data)))\n        values$sid.data$data <- data\n        shinyjs::show(\"SaveFeatureSelect\")\n      }, \n      error = function(e) {\n        print(e)\n      }\n    )\n  }\n)\n\nonclick(\n  id = \"simulateData\",\n  expr = {\n    values$sid.data <- list()\n    # parse covariates_normal areatext\n    str_normal <- unlist(strsplit(\n      x = str_replace_all(string = input$covariates_normal, \n                          pattern = \"[()]\", \n                          replacement = \"\"),\n      split = \"\\n\"))\n    covariates_normal <-\n      lapply(X = str_normal, FUN = function(str){\n        as.numeric(unlist(strsplit(x = str, split = \",\")))\n    })\n\n    # parse covariates_uniform areatext\n    str_uniform <- unlist(strsplit(\n      x = str_replace_all(string = input$covariates_uniform, \n                          pattern = \"[()]\", \n                          replacement = \"\"),\n      split = \"\\n\"))\n    covariates_uniform <-\n      lapply(X = str_uniform, FUN = function(str){\n        as.numeric(unlist(strsplit(x = str, split = \",\")))\n      })\n\n    # parse covariates_binomial areatext\n    str_binomial <- unlist(strsplit(\n      x = str_replace_all(string = input$covariates_binomial, \n                          pattern = \"[()]\", \n                          replacement = \"\"),\n      split = \"\\n\"))\n    covariates_binomial <-\n      lapply(X = str_binomial, FUN = function(str){\n        as.numeric(unlist(strsplit(x = str, split = \",\")))\n      })\n\n    # parse covariates_binary areatext\n    covariates_binary <- \n      as.numeric(\n        unlist(\n          strsplit(x = input$covariates_binary, \n                   split = \"\\n\")))\n\n    # parse correlation areatext\n    correlation <- \n      as.numeric(\n        unlist(\n          strsplit(x = input$correlation, \n                   split = \"\\n\")))\n    \n    values$sid.data <- \n      simulateSubgroupData(\n        N = input$N_samples,\n        case = input$case, \n        overal_treatment_effect = input$overal_treatment_effect, \n        subgroup_enhanced_effect = input$subgroup_enhanced_effect, \n        subgroup_shift_effect = input$subgroup_shift_effect,\n        subgroup_ratio = input$subgroup_ratio, \n        covariates_normal = covariates_normal,\n        covariates_uniform = covariates_uniform, \n        covariates_binomial = covariates_binomial, \n        covariates_binary = covariates_binary, \n        treatment_p = input$treatment_p, \n        rule_depth = input$rule_depth,\n        correlation = correlation, \n        SD_NOISE_RATIO = input$SD_NOISE_RATIO, \n        has_FP = input$has_FP\n      )\n\n    shinyjs::show(\"SaveFeatureSelect\")\n  }\n)\n\noutput$featureSummary <- renderPrint({\n  if(\"data\" %in% names(values$sid.data) &&\n     nrow(values$sid.data$data) > 0) {\n    summary(values$sid.data$data)\n  } else {\n    \"No data loaded.\"\n  }\n})\n\noutput$ruleSummary <- renderDataTable({\n  # TODO fix this\n  rules <- values$sid.data$rules\n  req(nrow(rules) > 0)\n  rules[rules$method %in% c(\"sim_TP\", \"sim_FP\"), ]\n})\n\n",
    "created" : 1565723882705.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3155303294",
    "id" : "6CA2F56B",
    "lastKnownWriteTime" : 1565809884,
    "last_content_update" : 1565809884257,
    "path" : "~/sidtoolbox/inst/shiny-examples/sidApp/src/server_setup.R",
    "project_path" : "inst/shiny-examples/sidApp/src/server_setup.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}