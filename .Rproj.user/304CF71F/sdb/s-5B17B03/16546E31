{
    "collab_server" : "",
    "contents" : "---\ntitle: \"sidtoolbox\"\noutput: html_document\nauthor: Marzie Rasekh\n---\n# Subgroup discovery demonstration\n\n```{r load_packaged, message=FALSE, warning=FALSE, include=FALSE}\n\n# or by indices\nlibrary(devtools)\nlibrary(roxygen2)\n\ninstall(\".\")\n# or load it\nlibrary(sidtoolbox)\n# update if changes made\n#document()\nlibrary(data.table)\nlibrary(stringr)\nlibrary(ggplot2)\n\n```\n\n# Simulated data\n\n\n```{r simulate_data}\n\n# simulate a sample dataset with 3 types of variables, numeric, binary, and count\n# covariates are X1, X2, ...\n# outcomes are Y_[type], namely Y_numeric, Y_binary, and Y_count\n# the contrast arm is TRT\n# 'N' samples will be created \n# also places two subgroups, oneis true positive (random_TP) of size 'subgroup_ratio'*'N' where the treatment arm is enhanced by 'subgroup_enhanced_effect'\n# and false positive (random_FP) of same size but where both arms are shifted by 'subgroup_shift_effect'\nsimulated.twoarm <- simulateSubgroupData(\n                            N = 2000,\n                            case = \"prognostic\", \n                            arm = \"two\",\n                            overal_treatment_effect = 0.5, \n                            subgroup_enhanced_effect = 1.5, \n                            subgroup_ratio = 0.1,\n                            covariates_normal = list(c(0,1), c(0,1), c(0,1)),\n                            correlation = c(),\n                            covariates_binary = c(0.5, 0.5, 0.5, 0.5), \n                            covariates_uniform = list(c(0,1), c(0,1), c(0,1)), \n                            has_FP = TRUE,\n                            SD_NOISE_RATIO = 0.1)\n#names(simulated.twoarm)\n# summary(simulated.twoarm$data)\nsimulated.twoarm\n\n```\n\n\n## Explore the data\nThis step helps identify covariates to be included in the subgroup discovery.\n\n### Correlation matrix\nCorrelations who one on one relation in your data. Highly correlated covariates should be removed.\n\n```{r exploreCorrelationMatrix}\n\n# examples\nexploreTriangleCorrelationMatrix(subgroup.data = simulated.twoarm, method = \"spearman\")\nexploreCorrelationMatrix(subgroup.data = simulated.twoarm)\nexploreDetailedChartCorrelation(subgroup.data = simulated.twoarm)\n\n\n```\n\n### Association rules\nAssociation rules help us find high level correlations in our data. \nThe rules are controled by support (how large the corresponding subgroup is) and confidence (how many of the total subgroup size follow the rule).\n\n```{r exploreAssociationRules, message=FALSE, warning=FALSE}\n\n# res <- exploreAssociationRules(subgroup.data)\nlistAssociationRules(subgroup.data = simulated.twoarm, onlyCovariates = FALSE)\nplotAssociationRules(subgroup.data = simulated.twoarm, onlyCovariates = TRUE)\nplotAssociationRules(subgroup.data = simulated.twoarm, method = \"graph\", measure = \"confidence\", onlyCovariates = TRUE)\nplotAssociationRules(subgroup.data = simulated.twoarm, method = \"scatterplot\", measure = \"support\", onlyCovariates = TRUE)\nplotAssociationRules(subgroup.data = simulated.twoarm, method = \"two-key plot\", measure = \"support\", onlyCovariates = FALSE)\n#plotAssociationRulesInteractive(subgroup.data = simulated.twoarm, onlyCovariates = TRUE)\n\n\n```\n\n### Conditional inference tree\nConditional inference trees are useful to fund the false positive subgroups, where both arms are shifted.\n\n\n```{r exploreDecisionTree, message=FALSE, warning=FALSE}\n# the true positive / false positive subgroup is\n# subgroup.data$rules\na <- sapply(exploreConditionalInferenceTree(subgroup.data = simulated.twoarm, stump = FALSE, testtype = \"Bonferroni\", teststat = \"max\", significance = 0.05, nmin = 0.05, maxdepth = 2), FUN = plot)\n\n```\n\n\n\n### Clustering \n\n\n```{r clustering}\n# coming soon\n\n```\n\n## Subgroup discovery\n\n```{r subgroup_discovery}\n# set the outcomes you want to run subgroup discovery on\noutcome_columns <- colnames(simulated.twoarm$data)[simulated.twoarm$outcomes]\n# save all rules in allRules\nallRules <- simulated.twoarm$rules\nallRules\n\n```\n\n### Treatment-specific Subgroup Discovery Tool (TSDT)\n<b>\nBattioui, C., Shen, L., Ruberg, S., (2014). <i>A Resampling-based Ensemble Tree Method to Identify\nPatient Subgroups with Enhanced Treatment Effect.</i> JSM proceedings, 2014 </b>\n\n```{r TSDT, message=FALSE, warning=FALSE}\n# the true positive / false positive subgroup is\n# simulated.twoarm$rules\n\nparam <- list(\n  desirable_response = \"increasing\",\n  nsamples = 100, \n  npermutations = 0, \n  maxdepth = 2, \n  min_subgroup_n_control = 0.05, \n  min_subgroup_n_trt = 0.05, \n  n_cpu = 1\n)\n\nresTSDT <- lapply(X = outcome_columns, FUN = function(y_idx) {\n  res <- runTSDT(subgroup.data = simulated.twoarm, \n                     y_idx = y_idx,\n                     desirable_response = param$desirable_response,\n                     nsamples = param$nsamples, \n                     npermutations = param$npermutations, \n                     maxdepth = param$maxdepth, \n                     min_subgroup_n_control = param$min_subgroup_n_control, \n                     min_subgroup_n_trt = param$min_subgroup_n_trt, \n                     n_cpu = param$n_cpu)\n  res\n  allRules <<- rbind(allRules, \n                    parseTSDTResults(TSDT_table = res, outcome = y_idx, param = param))\n})\n\nresTSDT\n\n```\n\n### Virtual Twins\n\nCurrently only supports binary outcomes and two arm studies.\n\n<b>Foster, Jared C., Jeremy MG Taylor, and Stephen J. Ruberg. <i>Subgroup identification from randomized clinical trial data.<i> Statistics in medicine 30.24 (2011): 2867-2880. \n<a href=\"https://www.ncbi.nlm.nih.gov/pubmed/21815180\">link</a></b>\n\n<a href=\"https://cran.r-project.org/web/packages/aVirtualTwins/index.html\">Link to implemented package</a>\n\n\n```{R virtual_twins, message=FALSE, warning=FALSE}\n# the true positive / false positive subgroup is\n# simulated.twoarm$rules\n\nparam <- list(\n  desirable_response = \"increasing\", \n  forest.type = \"double\",\n  method = \"absolute\", \n  tree.type = \"class\", \n  folds = 10, \n  ntree = 1000,\n  maxdepth = 2\n)\nidx <- sapply(X = outcome_columns, FUN = function(y){\n  x <- simulated.twoarm$data[, y, with = FALSE][[1]]\n  is.factor(x) && \n    length(levels(x) == 2)\n})\nbinary_outcomes <- outcome_columns[idx]\nresVT <- \n  lapply(X = binary_outcomes,\n       FUN = function(y_idx) {\n  res <- runVirtualTwins(subgroup.data = simulated.twoarm, \n                         y_idx = y_idx,\n                         desirable_response = param$desirable_response, \n                         forest.type = param$forest.type,\n                         method = param$method, \n                         tree.type = param$tree.type, \n                         folds = param$folds, \n                         ntree = param$ntree,\n                         maxdepth = param$maxdepth)\n  allRules <<- rbind(allRules,\n                    parseVTResults(VT_table = res, outcome = y_idx, param = param))\n  res\n})\n\nresVT\n\n```\n\n### Optimization approach with Particle Swarm Optimization (PSO)\n\n```{r PSO}\n# the true positive / false positive subgroup is\n# simulated.twoarm$rules\n\nresPSO <- lapply(X = outcome_columns,\n                 FUN = function(y_idx){\n  pso <- runPSO(subgroup.data = simulated.twoarm, \n                y_idx = y_idx, \n                fitness_method = \"model\", \n                desirable_response = \"increasing\", \n                depth = 2, \n                nmin = 0.1, \n                iterations = 100)\n  allRules <<- rbind(allRules, \n                     pso)\n  pso\n})\nresPSO\n\n\n\n```\n\n\n## Analyze and compare rules\n\n```{r compare_rules}\nMIN_P_VALUE <- 10e-10\nP_THRESHOLD <- -log10(0.05)\nsummarizeRules <- function(subgroup.data, rules) {\n  N.rules <- nrow(rules)\n  summaryRules <- data.table()\n  \n  allOutcomes <- outcome_columns\n  \n  for (i in c(1:N.rules)) {\n    row <- rules[i]\n    # adding a fix to remove dummy rules wihch were negative controls\n    if (!grepl(x = row$rule, pattern = \"dummy\")) {\n      if (str_length(row$outcome) == 0) {\n        Y <- allOutcomes\n      } else {\n        Y <- row$outcome\n      }\n      for (y in Y) {\n        row$outcome <- y\n        summaryRules <- rbind(summaryRules, row)\n      }\n    }\n    \n  }\n  N.rules <- nrow(summaryRules)\n  N <- nrow(simulated.twoarm$data)\n  effect_size <- sapply(\n    X = c(1:N.rules),\n    FUN = function(i) {\n      row <- summaryRules[i]\n      sbg_idx <-\n        parseRule(covariates = simulated.twoarm, rule = row$rule)\n      f <- interactionEffectSize(\n        subgroup.data = simulated.twoarm,\n        y_idx = row$outcome,\n        subgroup_idx = sbg_idx\n      )\n      c(\n        N_ratio = sum(sbg_idx) / N,\n        effect = f[1],\n        pvalue = f[2]\n      )\n    }\n  )\n  summaryRules$N_ratio <- effect_size[1, ]\n  summaryRules$interaction_coeff <- effect_size[2, ]\n  summaryRules$p_value <- effect_size[3, ]\n  summaryRules$p_value[summaryRules$p_value < MIN_P_VALUE] <- MIN_P_VALUE\n  # check TP rule and get accuracy precision recall\n  truth_subgroup <- which(rules$method == \"sim_TP\")\n  if (length(truth_subgroup) > 0) {\n    truth_subgroup <- parseRule(covariates = simulated.twoarm,\n                                rule = rules[truth_subgroup[1], ]$rule)\n    performance <- sapply(\n      X = c(1:N.rules),\n      FUN = function(i) {\n        row <- summaryRules[i, ]\n        sbg_idx <-\n          parseRule(covariates = simulated.twoarm, rule = row$rule)\n        TP <- sum(sbg_idx &  truth_subgroup)\n        FP <- sum(sbg_idx & !truth_subgroup)\n        TN <- sum(!sbg_idx & !truth_subgroup)\n        FN <- sum(!sbg_idx &  truth_subgroup)\n        precision <- TP / (TP + FP)\n        recall <- TP / (TP + FN)\n        F1  <- 2 * (recall * precision) / (precision + recall)\n        c(precision = precision,\n          recall = recall,\n          F1 = F1)\n      }\n    )\n    summaryRules$precision <- performance[1, ] * 100\n    summaryRules$recall <- performance[2, ] * 100\n    summaryRules$F1 <- performance[3, ] * 100\n  }\n  return(summaryRules)\n}\n\ndata <- summarizeRules(subgroup.data = simulated.twoarm, rules = allRules)\ndata$log_p_value <- -log10(data$p_value)\n  \ndata <- data[data$outcome == \"Y_binary\",]\nggplot(\n  data = data,\n  aes(\n    x = precision,\n    y = recall,\n    shape = outcome,\n    color = method\n  )\n) +\ngeom_point() +\nggtitle(\"Summary of rules\") +\ngeom_label(\n  label = data$method,\n  nudge_x = 0.25,\n  nudge_y = 0.2,\n  size = 5\n)\n\nggplot(\n  data = data,\n  aes(\n    x = interaction_coeff,\n    y = log_p_value,\n    shape = outcome,\n    color = method,\n     size = 10\n  )\n \n) +\ngeom_point() +\nggtitle(\"Summary of rules\") +\ngeom_text(\n  label = data$method,\n  size = 3\n) + \ngeom_hline(yintercept = P_THRESHOLD)\n\ndata\n\n```\n\n\n\n",
    "created" : 1565288183934.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2537738973",
    "id" : "16546E31",
    "lastKnownWriteTime" : 1565291452,
    "last_content_update" : 1565291452777,
    "path" : "~/sidtoolbox/demo_twoarm.Rmd",
    "project_path" : "demo_twoarm.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}